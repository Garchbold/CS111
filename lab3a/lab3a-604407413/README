#NOTE: My partner's UID is 404441309 and my UID is 604407413
#NOTE My partner has 1 slip day left and I have 2 slip days and we would like to combine our slip days to turn this project in on Thursday May 19th before midnight.
 
This file contains a c file named lab3a.c, this README, and a makefile which builds an executable, cleans objet files and the executable off and creates a tarbell with the .c file, this README and the Makefile.

The c file looks at a file system and prints out certain things.

1) First off we print out information about the superblock of the file system. The superblock is always 1024 bytes from the beginning of the file. We are easily able to generate the super.csv by looking at the offsets of things like the magic number, the amount of inodes per group and printing those out to the csv file. We store all this pertenent information in a structure that we will use to access important data like inodespergroup and the block size of the file system

2) We then take a look at all of the group descriptors. To determine the number of group descriptors we use the total number of blocks information and divide by the number of blocks per group. We then round this number up. For each group descriptor we know that the the first n - 1 groups will ahve blocks per group and the nth block group will have the remaining amount of blocks in it. In addition if the blocksize of the file system is 1024 bytes the group descriptor information will start at the 2048th byte, while if the blocksize is larger than that number, the block descriptor information will start at the beginning of the next block. It is important to recognize both options. Once in the correct offset we know each block group descriptor is 32 bytes long, so we can go through each group and gather where their block bitmap, inode bitmap, inode table are and other infromation like free inodes and free blocks. We also store this information in structures of which we have malloced number of block descriptors objects. 

3) Once we have gathered the information for our number of block descriptor objects we want to go through the bitmap and inode map and print out all of the free entries. We know how many blocks and inodes there are per group, so we go through that many bits for each corresponding block and inode bitmap. Every bit that is a 0 we mark as free and list their number in our csv file. Once we have gone through the specified number of blocks and inodes per group, we are not concerned with the bits after as they are garbage values. To single out the individual bits we read in byte after byte and use a mask to get the bits out.

4) We now want to gather information on each inode that is allocated, which means that it is marked as one in the inode bitmap. We know how many inodes there are that are valid by subtracting the inodes per group from the total number of inodes in the system. We allocate a structure to hold all the information that an inode stores like the file type, the mode, the access time, the number of blocks, and most importantly the block pointers. We then run through every inode within the range for each block descriptor and if it is not 0, then we pread in all the information from the corresponding data offsets. There is not real calculations we have to do here except figuring out what kind of file the inode points to which we do by seeing if the file mode of the inode falls within a certain decimal range corresponding to a file type's hexadecimal code. Once we are done outputting to inode.csv we have allocated inode structures for every full inode with correct corresponding inode identifiers.

5) To generate all the valid entries in directories, we traverse through all the allocated inodes and check if their file type is equal to 'd'. If the inode is in fact a directory, we record its inode number and traverse through all of the directories blocks printing out all the valid/allocated entries in each directory. We keep track of the valid entries by reading in 4 bytes from a part of the data block. If the inode number is valid and not a garbage value we get the length of the file entry and get the information on the file like the length of the file name and its name. We then increment our offset of where we read in the 4 bytes by the length of the file entry and we arrive at a new inode number. If the inode number we read in has value 0, then we have arrived at an invalid directory entry and we increment by 4 bytes and continue reading in inode numbers. Once we have read in a valid 4 byte value that corresponds to a valid inode number we know we have reached a valid inode and we acquire all the inodes information. Once we run out of room on one block we go to the directories next direct block and so on and so on until we go through all the indirect pointers as well. We call a funciton called block_pointer_search which takes in a valid block id and goes through all of the entries outputting the valid entries into directory.csv as we go. 

6) Finally to generate indirect block entries we go through every allocated inode and look into their indirect pointers. Specifically if the singly indirect block pointer is not 0, we pread the 4 byte id of the indirect block pointer and then we traverse through all the blocks it points to sending them to indirect.csv as we encounter non 0 value for the blocks. When we go into a doubly indirect block pointer it being 0 does not matter and we follow the same process as described above for each singly indirect pointer the doubly indirect pointer points to. The same logic applies to the triply indirect pointer. 
